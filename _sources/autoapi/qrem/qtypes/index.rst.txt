:py:mod:`qrem.qtypes`
=====================

.. py:module:: qrem.qtypes

.. autoapi-nested-parse::

   The *qtypes* subpackage provides classes for representing and manipulating data in *qrem* package.

   Submodules
   ----------
   circuit_collection
       Contains the *CircuitCollection* class, which represents a collection of quantum circuits and all information necessary to run characterisationexperiment on them.
   experiment_results
       Contains the *ExperimentResults* class, which represents the results of a quantum characterisation experiment.
   cn_noise_model
       Contains the *CNNoiseModel* class, which represents a noise model based on Clusters and Neighbors (CN) noise model.
   ctmp_noise_model
       Contains the *CTMPNoiseModel* class, which represents a noise model based on continuous-time Markov processes.
   datastructure_base
       Contains the *DataStructureBase* class, which represents a base class for data holding with helpful import/export functions.



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   characterization_data/index.rst
   circuit_collection/index.rst
   cn_noise_model/index.rst
   ctmp_noise_model/index.rst
   datastructure_base/index.rst
   experiment_results/index.rst
   mitigation_data/index.rst
   qunatum_detector_tomography_data/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   qrem.qtypes.CircuitCollection
   qrem.qtypes.CNModelData
   qrem.qtypes.CTMPModelData
   qrem.qtypes.ExperimentResults
   qrem.qtypes.DataStructureBase
   qrem.qtypes.CharacterizationData




.. py:class:: CircuitCollection


   Bases: :py:obj:`qrem.qtypes.datastructure_base.DataStructureBase`

   CircuitCollection class contains data about circuits to be prepared on a certain device for a specified experiment.

   :param device: Name of the device on which the circuits will be run.
   :type device: str
   :param experiment_type: Type of experiment, DDOT (Diagonal Detector Overlapping Tomography) or QDOT (Quantum Detector Overlapping Tomography).
   :type experiment_type: str
   :param circuits_list: List of circuits, where each circuit is a string of symbols (0-1 for DDOT, 0-5 for QDOT).
   :type circuits_list: list[str]
   :param qubit_indices: List of sorted indices of qubits on which the circuits are to be executed.
   :type qubit_indices: list[int]
   :param gate_error_threshold: Gate error on a qubit above which qubits are disregarded (circuits are not executed there).
   :type gate_error_threshold: float
   :param locality: The degree of marginals we wish to characterize.
   :type locality: int
   :param no_shots: How many times each circuit is executed.
   :type no_shots: int
   :param datetime_created_utc: When the circuit collection was created.
   :type datetime_created_utc: datetime
   :param author: Creator of the collection.
   :type author: str

   .. attribute:: device

      Name of the device on which the circuits will be run.

      :type: str

   .. attribute:: experiment_type

      Type of experiment, DDOT (Diagonal Detector Overlapping Tomography) or QDOT (Quantum Detector Overlapping Tomography).

      :type: str

   .. attribute:: circuits_labels

      List of circuits where each circuit is a string of symbols (0-1 for DDOT, 0-5 for QDOT).

      :type: list[str]

   .. attribute:: circuits

      Matrix representing circuits (shape: number_of_qubits x number_of_circuits, dtype: uint8).

      :type: numpy.ndarray

   .. attribute:: job_IDs

      After experiment is executed, it will be filled with relevant job_IDs (ibm) / task_ARNs (aws).

      :type: list[str]

   .. attribute:: qubit_indices

      List of sorted indices of qubits on which the circuits are to be executed.

      :type: list[int]

   .. attribute:: random_circuits_count

      Number of random circuits to be generated.

      :type: int

   .. attribute:: total_circuits_count

      Total number of circuits (random + predefined).

      :type: int

   .. attribute:: gate_error_threshold

      Gate error on a qubit above which qubits are disregarded (circuits are not executed there).

      :type: float

   .. attribute:: locality

      The degree of marginals we wish to characterize.

      :type: int

   .. attribute:: no_shots

      How many times each circuit is executed.

      :type: int

   .. attribute:: datetime_created_utc

      When the circuit collection was created.

      :type: datetime

   .. attribute:: experiment_name

      Name of the experiment.

      :type: str

   .. attribute:: author

      Creator of the collection.

      :type: str

   .. attribute:: metadata

      Additional metadata information.

      :type: list

   .. py:method:: load_config(config: qrem.common.config.QremConfigLoader)

      Load configuration settings into the CircuitCollection object.

      :param config: Configuration settings to load.
      :type config: QremConfigLoader


   .. py:method:: load_from_dict(dictionary)

      Load data from a dictionary into the CircuitCollection object.

      :param dictionary: Dictionary containing data to load into the object.
      :type dictionary: dict



.. py:class:: CNModelData(number_of_qubits: int)


   Bases: :py:obj:`qrem.qtypes.datastructure_base.DataStructureBase`

   Handles data for the Clusters and Neighbors (CN) noise model in quantum systems.

   This class is used for storing results from the CN noise model reconstruction algorithm and for mitigating readout errors
   on marginal probability distributions.

   :param number_of_qubits: The total number of qubits in the quantum system.
   :type number_of_qubits: int

   .. attribute:: clusters_tuple

      Information about clusters of qubits, where each tuple contains indices of qubits belonging to a cluster  e.g. ((0,2),(1,3).

      :type: Tuple[Tuple]

   .. attribute:: noise_matrices

      Noise matrices associated with each cluster, indexed by tuples of qubit indices. Eg. (0:2) : [[0.8,0,0,0], [0.2,1,0.1,0],[0,0,0.9,0],[0,0,0,1]].

      :type: Dict[Tuple,NDArray]

   .. attribute:: inverse_noise_matrices

      Inverse of the noise matrices, computed and stored for each cluster.  This property is filled automatically when noise_matrices property is set via set_noise_matrices_dictionary method.

      :type: dict

   .. attribute:: qubit_in_cluster_membership

      Maps individual qubits to the cluster they belong to. Key in the dictionary is a tuple constructed form a qubit index. Corresponding value is a cluster to which the qubit belongs.
      E.g. (2,) : (0,2,5). This property is filled automatically when noise_matrices property is set via set_noise_matrices_dictionary method

      :type: Dict[Tuple,Tuple]

   .. attribute:: composite_inverse_noise_matrices

      Stores the composite inverse noise matrices for different qubit combinations.

      :type: dict

   .. attribute:: clusters_neighborhoods

      Information about the neighborhoods of each cluster.

      :type: dict

   .. method:: set_noise_model :

      Sets up the noise model by initializing clusters, noise matrices, and their inverses.

   .. method:: compute_extended_inverse_noise_matrices :

      Computes the extended inverse noise matrix for a given marginal.

   .. method:: get_clusters_in_marginal_list :

      Returns the list of clusters involved in a specified marginal.

   .. method:: ...



   .. rubric:: Examples

   >>> model = CNModelData(number_of_qubits=5)
   >>> model.set_noise_model({_qubits_in_cluster_1: _noise_matrix_1, _qubits_in_cluster_2: _noise_matrix_2})
   >>> print(model.clusters_tuple)
   ((_qubits_in_cluster_1,), (_qubits_in_cluster_2,))

   .. py:method:: _establish_qubit_in_cluster_dictionary()

      Method used to establish membership of qubits in clusters.
      It constructs a dictionary with key - tuple consisting of a qubit index e.g. (0,) and value - tuple storing corresponding cluster e.g. (0,3)
      It is automatically called when set_clusters_tuple method is used.



   .. py:method:: _compute_inverse_noise_matrices()

      Method that creates inverse noise matrix dictionary for an instance of CN noise model.
      In the dictionary key corresponds to a tuple storing a cluster, and value to an numpy array storing inverse noise matrix e.g. (0,5): 4 by 4 numpy array.
      It is automatically called when set_noise_matrices_dictionary is used.



   .. py:method:: set_clusters_tuple(clusters_tuple: tuple)

      Method fills clusters_tuple property. It is called when properties of a CN noise model are established via set_noise_model method.
      In addition the method calls _establish_qubit_in_cluster_dictionary, which fills qubit_in_cluster_membership property



   .. py:method:: set_clusters_neighborhoods(clusters_neighborhoods: Dict[tuple, tuple])

      Method fills clusters_neighborhoods property. It is called when properties of a CN noise model are established via set_noise_model method.
      In addition the method calls _establish_qubit_in_cluster_dictionary, which fills qubit_in_cluster_membership property



   .. py:method:: set_noise_matrices_dictionary(noise_matrices_dictionary: Dict)

      Method fills noise_matrices property. It is called when properties of a CN noise model are established via set_noise_model method.
      In addition the method calls _compute_inverse_noise_matrices, which fills inverse_noise_matrices property.

      :param noise_matrices_dictionary: Dictionary storing noise matrices for a CN noise model. Key in the dictionary is a tuple with indices of qubits belonging to a cluster.
                                        Corresponding value is an array storing noise matrix associated with the cluster. Eg. (0:2) : [[0.8,0,0,0], [0.2,1,0.1,0],[0,0,0.9,0],[0,0,0,1]].
      :type noise_matrices_dictionary: dictionary (key - tuple of integers, value - array)


   .. py:method:: set_noise_model(noise_matrices_dictionary)

      Main method used to fill properties of CN noise model. The following properties are filled when the method is called:
      1) clusters_tuple
      2) qubit_in_cluster_membership
      3) noise_matrices
      4) inverse_noise_matrices


      :param noise_matrices_dictionary: Dictionary storing noise matrices for a CN noise model. Key in the dictionary is a tuple with indices of qubits belonging to a cluster.
                                        Corresponding value is an array storing noise matrix associated with the cluster. Eg. (0:2) : [[0.8,0,0,0], [0.2,1,0.1,0],[0,0,0.9,0],[0,0,0,1]].
      :type noise_matrices_dictionary: dictionary (key - tuple of integers, value - array)


   .. py:method:: compute_extended_inverse_noise_matrices(clusters_in_marginal_list: List[Tuple]) -> numpy.array

      Function determines inverse noise matrix for a given marginal. It is used as a step in mitigation_marginal function.
      The matrix is constructed as a tensor product on inverse noise matrices involved in a marginal, when it is necessary
      the matrix is permuted to ensure proper ordering of qubits indices. E.g. for a cluster_in_marginal_list
      [(0,2),(1,3)], the returned matrix corresponds to qubits ordered as (0,1,2,3).


      :param noise_model: An object of CNModelData class
      :type noise_model: object of CNModelData class
      :param clusters_in_marginal_list: A list of tuples with clusters involved in the marginal

      :returns: * *An inverse noise matrix for qubits specified in clusters_in_marginal_list, qubits are sorted in ascending order*
                * *(e.g. for a clusters_in_marginal_list =[(0,4),(1,8)], indices of the inverse noise matrix indices correspond to qubits in the order (0,1,4,8) )*


   .. py:method:: get_clusters_in_marginal_list(marginal: Tuple[int]) -> List[Tuple]

      Function creates a list of clusters that are involved in a marginal. Used in mitigation routines.
      For a given marginal inspects provided noise model and checks clusters membership of qubits form
      marginal.

      :param marginal: A tuple specifying marginal
      :type marginal: tuple
      :param noise_model: An object of CNModelData class
      :type noise_model: object of CNModelData class

      :returns: A list of tuples involved in the input marginal
      :rtype: clusters_in_marginal_list


   .. py:method:: get_clusters_and_neighborhoods_in_marginal_dictionary(marginal: Tuple[int]) -> Dict[Tuple[int], Tuple[int]]

      Function creates a list of clusters that are involved in a marginal. Used in mitigation routines.
      For a given marginal inspects provided noise model and checks clusters membership of qubits form
      marginal.

      :param marginal: A tuple specifying marginal
      :type marginal: tuple
      :param noise_model: An object of CNModelData class
      :type noise_model: object of CNModelData class

      :returns: A list of tuples involved in the input marginal
      :rtype: clusters_in_marginal_list


   .. py:method:: get_neighbors_in_marginal(marginal: Tuple[int]) -> Dict[Tuple[int], Tuple[int]]

      Function creates a dictionary with clusters and neighbors that belong to a marginal (it can happen that clusters' neighbors do not belong to other clusters that form a marginal .
      For a given marginal, and clusters and neighbors, membership of neighbors in the marginal is checked

      :param marginal: A tuple specifying marginal
      :type marginal: tuple
      :param noise_model: An object of CNModelData class
      :type noise_model: object of CNModelData class

      :returns: A list of tuples involved in the input marginal
      :rtype: clusters_in_marginal_list


   .. py:method:: get_noise_matrices_indexes(marginal: Tuple[int], state)

      Function creates a dictionary with indices of state dependent noise matrices that should be used to compute noise matrix inverse,

      It is used during error  mitigation of CN noise model with neighbors.

      :param marginal: A tuple specifying marginal
      :type marginal: tuple
      :param noise_model: An object of CNModelData class
      :type noise_model: object of CNModelData class

      :returns: A dictionary with a key - cluster and value - tuple of indicies to be averaged over or a string 'averaged'
      :rtype: neighbors_indices_to_compute_average


   .. py:method:: compute_extended_inverse_noise_matrices_state_dependent(clusters_in_marginal_list: List[Tuple], marginal, state) -> numpy.array

      Function determines inverse noise matrix for a given marginal. It is used as a step in mitigation_marginal function.
      The matrix is constructed as a tensor product on inverse noise matrices involved in a marginal, when it is necessary
      the matrix is permuted to ensure proper ordering of qubits indices. E.g. for a cluster_in_marginal_list
      [(0,2),(1,3)], the returned matrix corresponds to qubits ordered as (0,1,2,3).


      :param noise_model: An object of CNModelData class
      :type noise_model: object of CNModelData class
      :param clusters_in_marginal_list: A list of tuples with clusters involved in the marginal

      :returns: * *An inverse noise matrix for qubits specified in clusters_in_marginal_list, qubits are sorted in ascending order*
                * *(e.g. for a clusters_in_marginal_list =[(0,4),(1,8)], indices of the inverse noise matrix indices correspond to qubits in the order (0,1,4,8) )*


   .. py:method:: compute_specific_state_dependent_noise_matrix(cluster: Tuple[int], indicies: Tuple[Tuple[int]]) -> numpy.array



.. py:class:: CTMPModelData(rates: List[Tuple] = [], n: int = 0, gamma: float = None)


   Bases: :py:obj:`qrem.qtypes.datastructure_base.DataStructureBase`

   Represents the CTMP model for quantum error correction as described in Bravyi et al.

   This class stores information about quantum errors and their rates in a quantum system,
   especially focusing on qubits. It is part of the larger framework for managing quantum
   error correction and mitigation.

   :param rates: A list of tuples representing error types. Each error is a tuple of the form
                 (i, j, in, out, rate), where 'i' and 'j' are qubits the error acts on (i=j for
                 one qubit error), 'in' and 'out' are input and output bits of the error, and
                 'rate' is the rate of the given error. For example, (0, 2, "00", "11", 0.6)
                 represents an error flipping 0_0... to 1_1..., and (1, 1, "0", "1", 0.6) represents
                 an error flipping _0_... to _1_....
   :type rates: List[Tuple], optional
   :param n: The number of qubits in the quantum system.
   :type n: int, optional
   :param gamma: The CTMP noise strength as in eq. (13) from Bravyi et al. If None, it will be estimated
                 heuristically based on the provided rates.
   :type gamma: float, optional

   .. attribute:: rates

      Stores the error rates and types in the quantum system.

      :type: List[Tuple]

   .. attribute:: n

      The number of qubits in the quantum system.

      :type: int

   .. attribute:: gamma

      The noise strength in the CTMP model.

      :type: float

   .. method:: _estimate_gamma() -> float

      Estimates the gamma value heuristically if not provided.


   .. py:method:: _estimate_gamma() -> float

      Estimates the gamma value heuristically based on the provided error rates.

      This is a temporary solution and uses a simple sum of error rates. It is expected
      to be replaced with a more sophisticated estimation method.

      :returns: The estimated gamma value for the CTMP model.
      :rtype: float



.. py:class:: ExperimentResults(source=None)


   Bases: :py:obj:`qrem.qtypes.circuit_collection.CircuitCollection`

   The class contains results of an experiment in the counts variable. Qubit and classical outcome ordering is set to BigEndian format.
   Extends qrem.qtypes.CircuitCollection, so it contains description of circuits ran in the experiment (type of
   experiment, prepared states, used qubits, date etc.). Can be initialized based on existing CircuitCollection object.


   :param counts: The key is the label of a circuit (str), the value is a tuple containing all information about counts, according to following schematic:

                  counts = {"<circuit_label>": tuple(<RESTULS_MATRIX>, <COUNTS_VECTOR>)}

                  <circuit_label>: str, BigEndian-0 on left
                  <RESTULS_MATRIX>: np.array(m x n),dtype=bool, "BigEndian-like" -first on left )
                  <COUNTS_VECTOR>: np.array(m x 1),dtype=int)
   :type counts: dict

   frequencies (np.ndarray(c, 2^q)): array, where c is # of circuits, q is # of qubits, each entry contains
           frequency of a given state occurring in experiment result for given circuit.
           Possible states in a row are numbered increasingly from |00000 ... 0>, |10000 ... 0> up to |1111 ... 1>,
           Example: [[0.25, 0.00, 0.30, 0.45] ,
                     [0.00, 0.50, 0.50, 0.00]] is a result of 2 circuits on 2 qubits,
                     where in the first circuit outcome |00> occurred in 25% of shots, |10> in 0%, |01> in 0.30 etc.#TODO check if this is how we've used it so far

   original_counts: dict
       The key is the name of a circuit (str), the value is a dictionary of counts, where the key is a
       string denoting classical outcome and the value the number of its occurrences in given experiment.
       The circuits are named according to convention:
       circuit_name = "experiment name" + "-" + "circuit label" +
       "no" + "integer identifier for multiple implementations of the same circuit", e.g.: "DDOT-010no3"




   probabilities_list (List): TODO: find in code and comment what this is
   shots_results (List[List[str]] or np.ndarray(c, s, q)): measured outcome for each shot in each circuit, where
           c is # of circuits, s is # of shots in each circuit, q is # of qubits. Outcome saved as bitstring.
           Example: [['01001', '00100', '10101'],
                     ['01011', '11101', '01100']] is a result of 2 circuits on 5 qubits, 3 shots each circuit.
   tasks_IDs (str): device-specific ID for each circuit in the experiment, ordered #TODO - order how?
   datetime_obtained_utc: date of obtaining experiment results



.. py:class:: DataStructureBase


   Base class for data structures with export and import capabilities.

   .. attribute:: None



   .. method:: get_dict_format()

      Returns this class as a JSON-like dictionary structure.


   .. method:: load_from_dict(dictionary)

      Loads class fields from a dictionary.


   .. method:: to_json()

      Returns this class as a JSON structure.


   .. method:: export_json(json_export_path, overwrite=False)

      Saves the class into a JSON file.


   .. method:: import_json(json_import_path)

      Imports class fields from a JSON file.


   .. method:: get_pickle()

      Returns this class as a pickle structure.


   .. method:: export_pickle(pickle_export_path, overwrite=False)

      Saves the class into a pickle file.


   .. method:: import_pickle(pickle_import_path)

      Imports class fields from a pickle file.


   .. py:method:: get_dict_format()

      returns this class as a json-like dictionary structure


   .. py:method:: load_from_dict(dictionary)


   .. py:method:: to_json()

      returns this class as a json structure


   .. py:method:: export_json(json_export_path, overwrite=False)

      saves the class into json file


   .. py:method:: import_json(json_import_path)

      imports class' fields from json file


   .. py:method:: get_pickle()

      returns this class as a pickle structure


   .. py:method:: export_pickle(pickle_export_path, overwrite=False)

      saves the class into pickle file


   .. py:method:: import_pickle(pickle_import_path)

      imports class' fields from pickle file



.. py:class:: CharacterizationData


   Bases: :py:obj:`qrem.qtypes.datastructure_base.DataStructureBase`

   The class contains data about with characterization of readout noise results.


   :param marginals_dictionary: The key is the label of a circuit (str), the value is a tuple containing all information about counts, according to following schematic:
   :type marginals_dictionary: dict

       counts = {"<circuit_label>": Dict[Tuple[int], npt.NDArray[np.float_]]}

       <circuit_label>: str, BigEndian-0 on left
       Tuple[int]: tuple encoding subset
       npt.NDArray[np.float_]]: np.array(1 x 2**(subset_length)) - array storing probability of obtaining a particular result for a measurement obtained on that subset


   POVMs_dictionary: dict

       They key is tuple with qubits subset, value numpy array storing POVM effects


   noise_matrices_dictionary: dict
       The key is tuple with qubits subset, value a dictionary storing noise matrices.

       In the noise matrices dictionary the possible keys are:
           - the string 'averaged'
           - a tuple of ints encoding the neighborhood state. The qubits forming the neighborhood are stored in clusters_neighbors_sets_dictionary

   POMVs_errors_dictionary: dict
       A nested dictionary, with the structure [distance_name][distance_type][subset] where:
           distance_name: 'averaged_case' or 'worst_case'
           distance_type: 'classical' or 'quantum'
           subset: tuple of ints e.g. (0,1)

           The value corresponds to the value of a specified distance and reconstructed POVM to ideal computational basis  measurement

   correlation_coefficients_dictionary: dict
       A nested dictionary, with the structure [distance_name][distance_type]:
           distance_name: 'averaged_case' or 'worst_case'
           distance_type: 'classical' or 'quantum'
       The value is a numpy array with entries corresponding to the value of a correlation coefficient between qubits #TODO check direction of influence






   probabilities_list (List): TODO: find in code and comment what this is
   shots_results (List[List[str]] or np.ndarray(c, s, q)): measured outcome for each shot in each circuit, where
           c is # of circuits, s is # of shots in each circuit, q is # of qubits. Outcome saved as bitstring.
           Example: [['01001', '00100', '10101'],
                     ['01011', '11101', '01100']] is a result of 2 circuits on 5 qubits, 3 shots each circuit.
   tasks_IDs (str): device-specific ID for each circuit in the experiment, ordered #TODO - order how?
   datetime_obtained_utc: date of obtaining experiment results



