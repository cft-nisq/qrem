:py:mod:`qrem.qtypes.characterization_data`
===========================================

.. py:module:: qrem.qtypes.characterization_data


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   qrem.qtypes.characterization_data.CharacterizationData




.. py:class:: CharacterizationData


   Bases: :py:obj:`qrem.qtypes.datastructure_base.DataStructureBase`

   The class contains data about with characterization of readout noise results.


   :param marginals_dictionary: The key is the label of a circuit (str), the value is a tuple containing all information about counts, according to following schematic:
   :type marginals_dictionary: dict

       counts = {"<circuit_label>": Dict[Tuple[int], npt.NDArray[np.float_]]}

       <circuit_label>: str, BigEndian-0 on left
       Tuple[int]: tuple encoding subset
       npt.NDArray[np.float_]]: np.array(1 x 2**(subset_length)) - array storing probability of obtaining a particular result for a measurement obtained on that subset


   POVMs_dictionary: dict

       They key is tuple with qubits subset, value numpy array storing POVM effects


   noise_matrices_dictionary: dict
       The key is tuple with qubits subset, value a dictionary storing noise matrices.

       In the noise matrices dictionary the possible keys are:
           - the string 'averaged'
           - a tuple of ints encoding the neighborhood state. The qubits forming the neighborhood are stored in clusters_neighbors_sets_dictionary

   POMVs_errors_dictionary: dict
       A nested dictionary, with the structure [distance_name][distance_type][subset] where:
           distance_name: 'averaged_case' or 'worst_case'
           distance_type: 'classical' or 'quantum'
           subset: tuple of ints e.g. (0,1)

           The value corresponds to the value of a specified distance and reconstructed POVM to ideal computational basis  measurement

   correlation_coefficients_dictionary: dict
       A nested dictionary, with the structure [distance_name][distance_type]:
           distance_name: 'averaged_case' or 'worst_case'
           distance_type: 'classical' or 'quantum'
       The value is a numpy array with entries corresponding to the value of a correlation coefficient between qubits #TODO check direction of influence






   probabilities_list (List): TODO: find in code and comment what this is
   shots_results (List[List[str]] or np.ndarray(c, s, q)): measured outcome for each shot in each circuit, where
           c is # of circuits, s is # of shots in each circuit, q is # of qubits. Outcome saved as bitstring.
           Example: [['01001', '00100', '10101'],
                     ['01011', '11101', '01100']] is a result of 2 circuits on 5 qubits, 3 shots each circuit.
   tasks_IDs (str): device-specific ID for each circuit in the experiment, ordered #TODO - order how?
   datetime_obtained_utc: date of obtaining experiment results



